/*
##################################################################################

	Written by David Brandyberry, University of Illinois at Urbana-Champaign
	Please contact (brandyb2@illinois.edu) before distributing
	Last Updated September 2016

##################################################################################
*/
#include "RefinerGeometricalInclusion.h"
#include "Mesh.h"
#include "elem.h"
#include <iostream>
#include <algorithm>



/*
 * The Big 3
 * The constructor takes the problem that will be partitioned
 * Destructor doesn't do anything
 * Copy constructor copies over the problem pointer
 */
RefinerGeometricalInclusion::RefinerGeometricalInclusion(Problem* prob)
	: Refiner(prob)
{}
RefinerGeometricalInclusion::RefinerGeometricalInclusion()
{}
RefinerGeometricalInclusion::~RefinerGeometricalInclusion()
{}
RefinerGeometricalInclusion::RefinerGeometricalInclusion(const RefinerGeometricalInclusion& other)
{
	_prob = other.get_prob();
}




/*
 * The main interface with this class. Will be called to refine the mesh
 */
void RefinerGeometricalInclusion::refine()
{
	// If the mesh hasn't beeen refined before, set some things
	initialize_mesh_refinement();

	int level = 0;
	while (1)
	{
		// Generate the list of element codes for all local elements
		std::vector<unsigned char> elem_code;
		generate_element_code(elem_code);

		// Add any elements that been intersected multiple times to the list of elements that need refineing
		std::set<id_type> refined_elements;
		add_multiple_intersected_elements(refined_elements, elem_code);
		if (get_mesh()->get_rank()==0) std::cout << "\n\tDiscovered elements at level " << ++level;

		// If this is in serial and we found any new elements to refine, we will check again
		if (get_mesh()->serial())
		{
			if (refined_elements.size() == 0)
				break;
		}
		//Otherwise, perform a global reduction and see if any processor found 
		else
		{
			bool continue_refinement_local = (refined_elements.size() != 0);
			bool continue_refinement = false;
			MPI_Allreduce(&continue_refinement_local, &continue_refinement, 1, MPI_C_BOOL, MPI_LOR, get_mesh()->get_comm());
			if (!continue_refinement)
				break;
		}

		// Enforce the p-level constraints
		enforce_p_level_constraint(refined_elements);

		// Actually refine the elements
		if (get_mesh()->get_rank()==0) std::cout << "\n\tRefining elements at level " << level;
		refine_elements(refined_elements);
		if (get_mesh()->get_rank()==0) std::cout << "\n\tRefined elements at level " << level;

		// Determine the new node_elem structure
		get_mesh()->generate_node_elem();

		// Find all of the hanging nodes generated by this refinement
		get_mesh()->detect_hanging_nodes();
	}

	// Update the number of times the mesh has been refined
	get_mesh()->_mesh_topology++;
}




/*
 * This is the function that must be implemented to generate a set of elements to refine
 */
void RefinerGeometricalInclusion::generate_refine_set(std::set<id_type>& elements)
{
	// This is just stubbed out here because the structure of this refinement
	// doesn't exactly fit the refinement process laid out in Refiner.cpp
}




/*
 * Count the number of unique inclusions that intersect each local element
 */
void RefinerGeometricalInclusion::generate_element_code(std::vector<unsigned char>& elem_code)
{
	elem_code.resize( get_mesh()->n_local_elem() ); // Have an entry for every element but only the active ones will be non-zero
	for (Mesh::element_iterator it=get_mesh()->active_elements_begin(), end=get_mesh()->active_elements_end(); it!=end; ++it)
	{
		// Safety Check
		if ((*it)->h_level() != 1)
			err_message("I don't know how to handle refinement of elements with an order higher than linear...");

		id_type l_elem = get_mesh()->global_to_local_elem((*it)->get_id());

		// First build up the list of nodal detection values
		std::vector<int> nodal_detection( (*it)->n_nodes() );
		for (id_type n=0; n<(*it)->n_nodes(); ++n)
			nodal_detection[n] = get_mesh()->get_nodal_detection_local( get_mesh()->_elem_node[l_elem][n] );

		// Next find the unique values
		std::sort(nodal_detection.begin(), nodal_detection.end());
		std::vector<int>::iterator it2 = std::unique(nodal_detection.begin(), nodal_detection.end());
		nodal_detection.resize( std::distance(nodal_detection.begin(), it2) );

		// Count the number of nodal detection values that aren't in a subdomain material
		if (nodal_detection.size() > 1) // Not entirely contained in one material
			for (id_type i=0; i<nodal_detection.size(); ++i)
				if (nodal_detection[i] >= 0) // Count the number of non-matrix material points
					elem_code[l_elem]++;
	}
}




/*
 * Takes the element code and adds all the elements that satisfy the criterion of
 * being intersected by more then one inclusion
 */
void RefinerGeometricalInclusion::add_multiple_intersected_elements(std::set<id_type>& new_elements, const std::vector<unsigned char>& elem_code)
{
	for (id_type e=0; e<elem_code.size(); ++e)
		if (elem_code[e] > 1)
			new_elements.insert( e );
}