/*
##################################################################################

	Written by David Brandyberry, University of Illinois at Urbana-Champaign
	Please contact (brandyb2@illinois.edu) before distributing
	Last Updated September 2016

##################################################################################
*/
#include "RefinerGeometricalInclusionTraversal.h"
#include "Mesh.h"
#include "elem.h"
#include <iostream>
#include <algorithm>



/*
 * The Big 3
 * The constructor takes the problem that will be partitioned
 * Destructor doesn't do anything
 * Copy constructor copies over the problem pointer
 */
RefinerGeometricalInclusionTraversal::RefinerGeometricalInclusionTraversal(Problem* prob)
	: RefinerGeometricalInclusion(prob)
{}
RefinerGeometricalInclusionTraversal::~RefinerGeometricalInclusionTraversal()
{}
RefinerGeometricalInclusionTraversal::RefinerGeometricalInclusionTraversal(const RefinerGeometricalInclusionTraversal& other)
{
	_prob = other.get_prob();
}




/*
 * The main interface with this class. Will be called to refine the mesh
 */
void RefinerGeometricalInclusionTraversal::refine()
{
	// If the mesh hasn't beeen refined before, set some things
	initialize_mesh_refinement();

	int level = 0;
	while (1)
	{
		// Generate the list of element codes for all local elements
		std::vector<unsigned char> elem_code;
		generate_element_code(elem_code);

		// Add any elements that been intersected multiple times to the list of elements that need refineing
		std::set<id_type> refined_elements;
		add_multiple_intersected_elements(refined_elements, elem_code);

		traverse_inclusion_exterior(refined_elements, elem_code);

		// If this is in serial and we found any new elements to refine, we will check again
		if (get_mesh()->serial())
		{
			if (refined_elements.size() == 0)
				break;
		}
		//Otherwise, perform a global reduction and see if any processor found 
		else
		{
			bool continue_refinement_local = (refined_elements.size() != 0);
			bool continue_refinement = false;
			MPI_Allreduce(&continue_refinement_local, &continue_refinement, 1, MPI_C_BOOL, MPI_LOR, get_mesh()->get_comm());
			if (!continue_refinement)
				break;
		}

		// Enforce the p-level constraints
		enforce_p_level_constraint(refined_elements);

		// Actually refine the elements
		if (get_mesh()->get_rank()==0) std::cout << "\n\tRefining elements at level " << ++level;
		refine_elements(refined_elements);

		// Determine the new node_elem structure
		get_mesh()->generate_node_elem();

		// Find all of the hanging nodes generated by this refinement
		get_mesh()->detect_hanging_nodes();	
	}

	// Update the number of times the mesh has been refined
	get_mesh()->_mesh_topology++;
}



/*
 * Traverse the exterior of inclusions from an intial refinement point
 * This provides a better representation of the actual inclusion object
 */
void RefinerGeometricalInclusionTraversal::traverse_inclusion_exterior(std::set<id_type>& refined_elements,
																	   const std::vector<unsigned char>& elem_code)
{
	// Start by looping over all of the elements that are to be refined and find any p-level restrictions
	std::set<id_type> new_elements;
	new_elements.swap( refined_elements );
	bool continue_searching = true;
	while(continue_searching)
	{
		std::map<int, std::vector<id_type> > remote_additions;
		find_local_traversal_additions(refined_elements, new_elements, remote_additions, elem_code);

		// If the mesh is serial then I've found all of the p-level additions
		if (get_mesh()->serial())
			continue_searching = false;

		// If the mesh isn't serial, I could get new eleents to refine from a remote
		// processor which could lead me to find more on my local partition
		else
		{
			std::set<id_type> new_local_elements;
			communicate_new_remote_elements(refined_elements, new_local_elements, remote_additions);

			// If any processor got new elements then I should continue searching the whole mesh
			bool continue_searching_local = false;
			if (new_local_elements.size() != 0)
			{
				continue_searching = true;
				new_elements.swap(new_local_elements); // Swap with the set of elements that I should begin my search with next time
			}
			MPI_Allreduce(&continue_searching_local, &continue_searching, 1, MPI_C_BOOL, MPI_LOR, get_mesh()->get_comm());
		}
	}
}




/*
 * Adds to the set refined_elements all those elements that are neighbors of the new_elements.
 * Also adds lists of new remote elements that should be refined in parallel
 */
void RefinerGeometricalInclusionTraversal::find_local_traversal_additions(std::set<id_type>& refined_elements, std::set<id_type>& new_elements,
																		  std::map<int, std::vector<id_type> >& remote_additions,
																		  const std::vector<unsigned char>& elem_code)
{
	// Add an empty vector of additional elements to the remote structure for every processor I neighbor
	for (auto it=get_mesh()->_proc_neighbors.begin(), end=get_mesh()->_proc_neighbors.end(); it!=end; ++it)
		remote_additions.insert(std::pair<int, std::vector<id_type> >(*it, std::vector<id_type>()));

	// Find all of the elements on the local process that should be added based on the info I currently have
	std::set<id_type> neighbors;
	while (new_elements.size()>0)
	{
		// Add all of the new eleents to the total list
		refined_elements.insert(new_elements.begin(), new_elements.end());

		// Loop over all new elements and find their enriched neighbors
		for (auto it=new_elements.begin(), end=new_elements.end(); it!=end; ++it)
		{
			// Get the local element number
			id_type l_elem = *it;
			Elem* el = get_mesh()->get_elem_local(l_elem);

			// Loop over all of the element's nodes
			for (id_type n=0; n<el->n_nodes(); ++n)
			{
				id_type l_node = get_mesh()->global_to_local_node(el->get_node(n)->get_id());

				// Loop over all of the node element neighbors
				std::vector<id_type>& elem_neighbors = get_mesh()->get_node_elem_local( l_node );
				for (id_type e=0; e<elem_neighbors.size(); ++e)
				{
					id_type l_elem2 = get_mesh()->global_to_local_elem(elem_neighbors[e]);
					if (elem_code[l_elem2] != 0) // intersected
						neighbors.insert( l_elem2 );
				}

				// Get the remote_node_elem result and add it to the appropriate send lists
				auto it2 = get_mesh()->_remote_node_elem.find(el->get_node(n)->get_id());
				if (it2 != get_mesh()->_remote_node_elem.end())
				{
					for (auto it3=(*it2).second.begin(), end3=(*it2).second.end(); it3!=end3; ++it3)
					{
						int part = it3->first;
						std::vector<id_type>& my_vec = remote_additions[part]; // Grab a reference for simpler syntax's sake
						my_vec.insert(my_vec.end(), (*it3).second.begin(), (*it3).second.end()); // Note: this will contain duplicates but oh well
					}
				}
			}
		}

		// Find the set difference
		new_elements.clear();
		std::set_difference(neighbors.begin(), neighbors.end(),
							refined_elements.begin(), refined_elements.end(), 
	                    	std::inserter(new_elements, new_elements.begin()));
		neighbors.clear();
	}
}